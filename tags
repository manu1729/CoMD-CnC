!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ATOMS	Context.h	/^	ItemCollectionEntry **ATOMS;$/;"	m	struct:Context
ATOMSItem	Context.h	/^typedef struct { Atoms *item; cncHandle_t handle; } ATOMSItem;$/;"	t	typeref:struct:__anon11
AngsInMeters	constants.h	22;"	d
AperB	Context.h	/^	ItemCollectionEntry **AperB;$/;"	m	struct:Context
AperBItem	Context.h	/^typedef struct { int item; cncHandle_t handle; } AperBItem;$/;"	t	typeref:struct:__anon22
AtomExchangeParms	haloExchange.c	/^AtomExchangeParms;$/;"	t	typeref:struct:AtomExchangeParmsSt	file:
AtomExchangeParmsSt	haloExchange.c	/^typedef struct AtomExchangeParmsSt$/;"	s	file:
AtomMsg	haloExchange.c	/^AtomMsg;$/;"	t	typeref:struct:AtomMsgSt	file:
AtomMsgSt	haloExchange.c	/^typedef struct AtomMsgSt$/;"	s	file:
Atoms	initAtoms.h	/^} Atoms;$/;"	t	typeref:struct:AtomsSt
AtomsSt	initAtoms.h	/^typedef struct AtomsSt$/;"	s
B	Context.h	/^	ItemCollectionEntry **B;$/;"	m	struct:Context
BItem	Context.h	/^typedef struct { struct box *item; cncHandle_t handle; } BItem;$/;"	t	typeref:struct:__anon1
BasePotential	CoMDTypes.h	/^} BasePotential;$/;"	t	typeref:struct:BasePotentialSt
BasePotentialSt	CoMDTypes.h	/^typedef struct BasePotentialSt$/;"	s
CC	Makefile	/^CC = gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS = -std=c99$/;"	m
CMDLINEPARSER_H_	cmdLineParser.h	8;"	d
C_LIB	Makefile	/^C_LIB = -lm$/;"	m
CoMDVariant	yamlOutput.c	/^static const char* CoMDVariant = "CnC";$/;"	v	file:
CoMDVersion	yamlOutput.c	/^static const char* CoMDVersion = "1.1";$/;"	v	file:
CoMD_VARIANT	Makefile	/^CoMD_VARIANT = CnC$/;"	m
Command	mycommand.h	/^} Command;$/;"	t	typeref:struct:CommandSt
CommandSt	mycommand.h	/^typedef struct CommandSt$/;"	s
Context	Context.h	/^typedef struct Context {$/;"	s
Context	Context.h	/^} Context;$/;"	t	typeref:struct:Context
DD	Context.h	/^	ItemCollectionEntry **DD;$/;"	m	struct:Context
DDItem	Context.h	/^typedef struct { Domain *item; cncHandle_t handle; } DDItem;$/;"	t	typeref:struct:__anon8
DOUBLE_PRECISION	Makefile	/^DOUBLE_PRECISION = ON$/;"	m
DO_MPI	Makefile	/^DO_MPI = OFF$/;"	m
Domain	decomposition.h	/^} Domain;$/;"	t	typeref:struct:DomainSt
DomainSt	decomposition.h	/^typedef struct DomainSt$/;"	s
EMT1	mytype.h	11;"	d
EMT1	mytype.h	15;"	d
F	Context.h	/^	ItemCollectionEntry **F;$/;"	m	struct:Context
FItem	Context.h	/^typedef struct { real3 *item; cncHandle_t handle; } FItem;$/;"	t	typeref:struct:__anon16
FMT1	mytype.h	10;"	d
FMT1	mytype.h	14;"	d
ForceExchangeParms	haloExchange.c	/^ForceExchangeParms;$/;"	t	typeref:struct:ForceExchangeParmsSt	file:
ForceExchangeParmsSt	haloExchange.c	/^typedef struct ForceExchangeParmsSt$/;"	s	file:
ForceMsg	haloExchange.c	/^ForceMsg;$/;"	t	typeref:struct:ForceMsgSt	file:
ForceMsgSt	haloExchange.c	/^typedef struct ForceMsgSt$/;"	s	file:
GID	Context.h	/^	ItemCollectionEntry **GID;$/;"	m	struct:Context
GIDItem	Context.h	/^typedef struct { int *item; cncHandle_t handle; } GIDItem;$/;"	t	typeref:struct:__anon12
HALO_X_AXIS	haloExchange.c	/^enum HaloAxisOrder {HALO_X_AXIS, HALO_Y_AXIS, HALO_Z_AXIS};$/;"	e	enum:HaloAxisOrder	file:
HALO_X_MINUS	haloExchange.c	/^enum HaloFaceOrder {HALO_X_MINUS, HALO_X_PLUS,$/;"	e	enum:HaloFaceOrder	file:
HALO_X_PLUS	haloExchange.c	/^enum HaloFaceOrder {HALO_X_MINUS, HALO_X_PLUS,$/;"	e	enum:HaloFaceOrder	file:
HALO_Y_AXIS	haloExchange.c	/^enum HaloAxisOrder {HALO_X_AXIS, HALO_Y_AXIS, HALO_Z_AXIS};$/;"	e	enum:HaloAxisOrder	file:
HALO_Y_MINUS	haloExchange.c	/^                    HALO_Y_MINUS, HALO_Y_PLUS,$/;"	e	enum:HaloFaceOrder	file:
HALO_Y_PLUS	haloExchange.c	/^                    HALO_Y_MINUS, HALO_Y_PLUS,$/;"	e	enum:HaloFaceOrder	file:
HALO_Z_AXIS	haloExchange.c	/^enum HaloAxisOrder {HALO_X_AXIS, HALO_Y_AXIS, HALO_Z_AXIS};$/;"	e	enum:HaloAxisOrder	file:
HALO_Z_MINUS	haloExchange.c	/^                    HALO_Z_MINUS, HALO_Z_PLUS};$/;"	e	enum:HaloFaceOrder	file:
HALO_Z_PLUS	haloExchange.c	/^                    HALO_Z_MINUS, HALO_Z_PLUS};$/;"	e	enum:HaloFaceOrder	file:
HaloAxisOrder	haloExchange.c	/^enum HaloAxisOrder {HALO_X_AXIS, HALO_Y_AXIS, HALO_Z_AXIS};$/;"	g	file:
HaloExchange	haloExchange.h	/^HaloExchange;$/;"	t	typeref:struct:HaloExchangeSt
HaloExchangeSt	haloExchange.h	/^typedef struct HaloExchangeSt$/;"	s
HaloFaceOrder	haloExchange.c	/^enum HaloFaceOrder {HALO_X_MINUS, HALO_X_PLUS,$/;"	g	file:
INCLUDES	Makefile	/^INCLUDES = $/;"	m
ISP	Context.h	/^	ItemCollectionEntry **ISP;$/;"	m	struct:Context
ISPItem	Context.h	/^typedef struct { int *item; cncHandle_t handle; } ISPItem;$/;"	t	typeref:struct:__anon13
IT	Context.h	/^	ItemCollectionEntry **IT;$/;"	m	struct:Context
ITItem	Context.h	/^typedef struct { int item; cncHandle_t handle; } ITItem;$/;"	t	typeref:struct:__anon19
LC	Context.h	/^	ItemCollectionEntry **LC;$/;"	m	struct:Context
LCItem	Context.h	/^typedef struct { LinkCell *item; cncHandle_t handle; } LCItem;$/;"	t	typeref:struct:__anon9
LinkCell	linkCells.h	/^} LinkCell;$/;"	t	typeref:struct:LinkCellSt
LinkCellSt	linkCells.h	/^typedef struct LinkCellSt$/;"	s
LjPotential	CoMDTypes.h	/^} LjPotential;$/;"	t	typeref:struct:LjPotentialSt
LjPotentialSt	CoMDTypes.h	/^typedef struct LjPotentialSt$/;"	s
MAX	haloExchange.c	43;"	d	file:
MAX	linkCells.c	77;"	d	file:
MAXATOMS	linkCells.h	10;"	d
MAYBE_UNUSED	Common.c	8;"	d	file:
MIN	linkCells.c	76;"	d	file:
MYCOMMAND_H	mycommand.h	5;"	d
MyOption	cmdLineParser.c	/^} MyOption;$/;"	t	typeref:struct:MyOptionSt	file:
MyOptionSt	cmdLineParser.c	/^typedef struct MyOptionSt$/;"	s	file:
NAtoms	Context.h	/^	ItemCollectionEntry **NAtoms;$/;"	m	struct:Context
NAtomsItem	Context.h	/^typedef struct { int *item; cncHandle_t handle; } NAtomsItem;$/;"	t	typeref:struct:__anon10
Nbs	Context.h	/^	ItemCollectionEntry **Nbs;$/;"	m	struct:Context
NbsItem	Context.h	/^typedef struct { int item; cncHandle_t handle; } NbsItem;$/;"	t	typeref:struct:__anon23
OBJS	Makefile	/^OBJS=$(patsubst %.c,%.o,$(SRCS))$/;"	m
OPTFLAGS	Makefile	/^OPTFLAGS = -g -O5$/;"	m
P	Context.h	/^	ItemCollectionEntry **P;$/;"	m	struct:Context
PItem	Context.h	/^typedef struct { real3 *item; cncHandle_t handle; } PItem;$/;"	t	typeref:struct:__anon15
POT	Context.h	/^	ItemCollectionEntry **POT;$/;"	m	struct:Context
POTItem	Context.h	/^typedef struct { LjPotential *item; cncHandle_t handle; } POTItem;$/;"	t	typeref:struct:__anon6
POT_SHIFT	forceStep.c	17;"	d	file:
POT_SHIFT	ljForce.c	77;"	d	file:
R	Context.h	/^	ItemCollectionEntry **R;$/;"	m	struct:Context
REAL_MPI_TYPE	parallel.c	24;"	d	file:
REAL_MPI_TYPE	parallel.c	26;"	d	file:
RItem	Context.h	/^typedef struct { real3 *item; cncHandle_t handle; } RItem;$/;"	t	typeref:struct:__anon14
RankReduceData	parallel.h	/^} RankReduceData;$/;"	t	typeref:struct:RankReduceDataSt
RankReduceDataSt	parallel.h	/^typedef struct RankReduceDataSt$/;"	s
SF	Context.h	/^	ItemCollectionEntry **SF;$/;"	m	struct:Context
SFItem	Context.h	/^typedef struct { SimFlat *item; cncHandle_t handle; } SFItem;$/;"	t	typeref:struct:__anon5
SPECIES	Context.h	/^	ItemCollectionEntry **SPECIES;$/;"	m	struct:Context
SPECIESItem	Context.h	/^typedef struct { SpeciesData *item; cncHandle_t handle; } SPECIESItem;$/;"	t	typeref:struct:__anon7
SRCS	Makefile	/^SRCS= Common.c Context.c Dispatch.c $(STEP_SRCS) cmdLineParser.c mycommand.c random.c parallel.c$/;"	m
STEP_SRCS	steplist.mk	/^STEP_SRCS=advanceVelocityStep.c advancePositionStep.c updatedAtomInfoStep.c updateBoxStep.c syncBoxesStep.c generateForceTagsStep.c forceStep.c reduceStep.c $/;"	m
SimFlat	CoMDTypes.h	/^} SimFlat;$/;"	t	typeref:struct:SimFlatSt
SimFlatSt	CoMDTypes.h	/^typedef struct SimFlatSt$/;"	s
SpeciesData	CoMDTypes.h	/^} SpeciesData;$/;"	t	typeref:struct:SpeciesDataSt
SpeciesDataSt	CoMDTypes.h	/^typedef struct SpeciesDataSt$/;"	s
TARGET	Makefile	/^TARGET=comd.exe$/;"	m
TAtoms	Context.h	/^	ItemCollectionEntry **TAtoms;$/;"	m	struct:Context
TAtomsItem	Context.h	/^typedef struct { int item; cncHandle_t handle; } TAtomsItem;$/;"	t	typeref:struct:__anon21
TBoxes	Context.h	/^	ItemCollectionEntry **TBoxes;$/;"	m	struct:Context
TBoxesItem	Context.h	/^typedef struct { int item; cncHandle_t handle; } TBoxesItem;$/;"	t	typeref:struct:__anon20
U	Context.h	/^	ItemCollectionEntry **U;$/;"	m	struct:Context
U	initAtoms.h	/^   real_t* U;     \/\/!< potential energy per atom$/;"	m	struct:AtomsSt
UI	Context.h	/^	ItemCollectionEntry **UI;$/;"	m	struct:Context
UIItem	Context.h	/^typedef struct { struct info *item; cncHandle_t handle; } UIItem;$/;"	t	typeref:struct:__anon2
UItem	Context.h	/^typedef struct { real_t *item; cncHandle_t handle; } UItem;$/;"	t	typeref:struct:__anon17
Validate	CoMDTypes.h	/^} Validate;$/;"	t	typeref:struct:ValidateSt
ValidateSt	CoMDTypes.h	/^typedef struct ValidateSt$/;"	s
_CNC_STEPS_H	Dispatch.h	5;"	d
_COMMON_H	Common.h	6;"	d
_CONSTANTS_H_	constants.h	13;"	d
_CONTEXT	Context.h	5;"	d
_GEOMETRY_H_	decomposition.h	5;"	d
_LJTYPES_H_	ljForce.h	5;"	d
_MEMUTILS_H_	memUtils.h	5;"	d
_PARALLEL_H_	parallel.h	5;"	d
__COMDTYPES_H_	CoMDTypes.h	5;"	d
__HALO_EXCHANGE_	haloExchange.h	5;"	d
__INIT_ATOMS_H	initAtoms.h	5;"	d
__LEAPFROG_H	timestep.h	5;"	d
__LINK_CELLS_H_	linkCells.h	5;"	d
__MYTYPE_H_	mytype.h	5;"	d
__RANDOM_H	random.h	6;"	d
__YAML_OUTPUT_H	yamlOutput.h	5;"	d
__cncPrescribe_cncEnvOut	Common.c	/^void __cncPrescribe_cncEnvOut(int i, int iter, Context *context){$/;"	f
addArg	cmdLineParser.c	/^int addArg(const char* longOption, const char shortOption,$/;"	f
addDoubleParallel	parallel.c	/^void addDoubleParallel(double* sendBuf, double* recvBuf, int count)$/;"	f
addIntParallel	parallel.c	/^void addIntParallel(int* sendBuf, int* recvBuf, int count)$/;"	f
addRealParallel	parallel.c	/^void addRealParallel(real_t* sendBuf, real_t* recvBuf, int count)$/;"	f
advancePosition	timestep.c	/^void advancePosition(SimFlat* s, int nBoxes, real_t dt)$/;"	f
advancePositionStep	Context.h	/^	ocrGuid_t advancePositionStep;$/;"	m	struct:Context
advancePositionStep	advancePositionStep.c	/^void advancePositionStep (int i, int iter, BItem b1, SFItem sf,  Context *context) {$/;"	f
advancePositionStep_gets	Common.c	/^ocrGuid_t advancePositionStep_gets(u32 paramc, u64 paramv[], u32 depc, ocrEdtDep_t depv[]){$/;"	f
advanceVelocity	timestep.c	/^void advanceVelocity(SimFlat* s, int nBoxes, real_t dt)$/;"	f
advanceVelocityStep	Context.h	/^	ocrGuid_t advanceVelocityStep;$/;"	m	struct:Context
advanceVelocityStep	advanceVelocityStep.c	/^void advanceVelocityStep (int i, int iter, BItem b1, SFItem sf, Context *context) {$/;"	f
advanceVelocityStep_gets	Common.c	/^ocrGuid_t advanceVelocityStep_gets(u32 paramc, u64 paramv[], u32 depc, ocrEdtDep_t depv[]){$/;"	f
amuInKilograms	constants.h	16;"	d
amuToInternalMass	constants.h	/^static const double amuToInternalMass =$/;"	v
argFlag	cmdLineParser.c	/^   int argFlag;$/;"	m	struct:MyOptionSt	file:
atomExchange	CoMDTypes.h	/^   HaloExchange* atomExchange;$/;"	m	struct:SimFlatSt
atomicNo	CoMDTypes.h	/^   int   atomicNo;     \/\/!< atomic number$/;"	m	struct:BasePotentialSt
atomicNo	CoMDTypes.h	/^   int   atomicNo;     \/\/!< atomic number$/;"	m	struct:LjPotentialSt
atomicNo	CoMDTypes.h	/^   int   atomicNo;  \/\/!< atomic number$/;"	m	struct:SpeciesDataSt
atoms	CoMDTypes.h	/^   Atoms* atoms;          \/\/<! atom data (positions, momenta, ...)$/;"	m	struct:SimFlatSt
barrierParallel	parallel.c	/^void barrierParallel()$/;"	f
bcastParallel	parallel.c	/^void bcastParallel(void* buf, int count, int root)$/;"	f
bohrToAngs	constants.h	/^static const double bohrToAngs = 0.52917721092;$/;"	v
box	CoMDTypes.h	/^struct box {$/;"	s
boxSize	linkCells.h	/^   real3 boxSize;       \/\/!< size of box in each dimension$/;"	m	struct:LinkCellSt
boxes	CoMDTypes.h	/^   LinkCell* boxes;       \/\/<! link-cell data$/;"	m	struct:SimFlatSt
bufCapacity	haloExchange.h	/^   int bufCapacity;$/;"	m	struct:HaloExchangeSt
builtWithMpi	parallel.c	/^int builtWithMpi(void)$/;"	f
cellList	haloExchange.c	/^   int* cellList[6];     \/\/!< List of link cells from which to load data for each face.$/;"	m	struct:AtomExchangeParmsSt	file:
cncCreateItemSized_ATOMS	Context.c	/^cncHandle_t cncCreateItemSized_ATOMS(Atoms **item, size_t size) {$/;"	f
cncCreateItemSized_AperB	Context.c	/^cncHandle_t cncCreateItemSized_AperB(int **item, size_t size) {$/;"	f
cncCreateItemSized_B	Context.c	/^cncHandle_t cncCreateItemSized_B(struct box **item, size_t size) {$/;"	f
cncCreateItemSized_DD	Context.c	/^cncHandle_t cncCreateItemSized_DD(Domain **item, size_t size) {$/;"	f
cncCreateItemSized_F	Context.c	/^cncHandle_t cncCreateItemSized_F(real3 **item, size_t size) {$/;"	f
cncCreateItemSized_GID	Context.c	/^cncHandle_t cncCreateItemSized_GID(int **item, size_t size) {$/;"	f
cncCreateItemSized_ISP	Context.c	/^cncHandle_t cncCreateItemSized_ISP(int **item, size_t size) {$/;"	f
cncCreateItemSized_IT	Context.c	/^cncHandle_t cncCreateItemSized_IT(int **item, size_t size) {$/;"	f
cncCreateItemSized_LC	Context.c	/^cncHandle_t cncCreateItemSized_LC(LinkCell **item, size_t size) {$/;"	f
cncCreateItemSized_NAtoms	Context.c	/^cncHandle_t cncCreateItemSized_NAtoms(int **item, size_t size) {$/;"	f
cncCreateItemSized_Nbs	Context.c	/^cncHandle_t cncCreateItemSized_Nbs(int **item, size_t size) {$/;"	f
cncCreateItemSized_P	Context.c	/^cncHandle_t cncCreateItemSized_P(real3 **item, size_t size) {$/;"	f
cncCreateItemSized_POT	Context.c	/^cncHandle_t cncCreateItemSized_POT(LjPotential **item, size_t size) {$/;"	f
cncCreateItemSized_R	Context.c	/^cncHandle_t cncCreateItemSized_R(real3 **item, size_t size) {$/;"	f
cncCreateItemSized_SF	Context.c	/^cncHandle_t cncCreateItemSized_SF(SimFlat **item, size_t size) {$/;"	f
cncCreateItemSized_SPECIES	Context.c	/^cncHandle_t cncCreateItemSized_SPECIES(SpeciesData **item, size_t size) {$/;"	f
cncCreateItemSized_TAtoms	Context.c	/^cncHandle_t cncCreateItemSized_TAtoms(int **item, size_t size) {$/;"	f
cncCreateItemSized_TBoxes	Context.c	/^cncHandle_t cncCreateItemSized_TBoxes(int **item, size_t size) {$/;"	f
cncCreateItemSized_U	Context.c	/^cncHandle_t cncCreateItemSized_U(real_t **item, size_t size) {$/;"	f
cncCreateItemSized_UI	Context.c	/^cncHandle_t cncCreateItemSized_UI(struct info **item, size_t size) {$/;"	f
cncCreateItemSized_count	Context.c	/^cncHandle_t cncCreateItemSized_count(int **item, size_t size) {$/;"	f
cncCreateItemSized_redc	Context.c	/^cncHandle_t cncCreateItemSized_redc(struct myReduction **item, size_t size) {$/;"	f
cncCreateItemSized_s	Context.c	/^cncHandle_t cncCreateItemSized_s(int **item, size_t size) {$/;"	f
cncCreateItem_ATOMS	Context.h	90;"	d
cncCreateItem_AperB	Context.h	112;"	d
cncCreateItem_B	Context.h	70;"	d
cncCreateItem_DD	Context.h	84;"	d
cncCreateItem_F	Context.h	100;"	d
cncCreateItem_GID	Context.h	92;"	d
cncCreateItem_ISP	Context.h	94;"	d
cncCreateItem_IT	Context.h	106;"	d
cncCreateItem_LC	Context.h	86;"	d
cncCreateItem_NAtoms	Context.h	88;"	d
cncCreateItem_Nbs	Context.h	114;"	d
cncCreateItem_P	Context.h	98;"	d
cncCreateItem_POT	Context.h	80;"	d
cncCreateItem_R	Context.h	96;"	d
cncCreateItem_SF	Context.h	78;"	d
cncCreateItem_SPECIES	Context.h	82;"	d
cncCreateItem_TAtoms	Context.h	110;"	d
cncCreateItem_TBoxes	Context.h	108;"	d
cncCreateItem_U	Context.h	102;"	d
cncCreateItem_UI	Context.h	72;"	d
cncCreateItem_count	Context.h	74;"	d
cncCreateItem_redc	Context.h	104;"	d
cncCreateItem_s	Context.h	76;"	d
cncEnvFreeEdt	Dispatch.c	/^ocrGuid_t cncEnvFreeEdt(u32 paramc, u64 paramv[], u32 depc, ocrEdtDep_t depv[]) {$/;"	f
cncEnvIn	Main.c	/^void cncEnvIn(int argc, char** argv, Context *context) {$/;"	f
cncEnvInEdt	Dispatch.c	/^ocrGuid_t cncEnvInEdt(u32 paramc, u64 paramv[], u32 depc, ocrEdtDep_t depv[]) {$/;"	f
cncEnvOut	Context.h	/^	ocrGuid_t cncEnvOut;$/;"	m	struct:Context
cncEnvOut	Main.c	/^void cncEnvOut(int i, int iter, BItem B, redcItem r, Context *context) {$/;"	f
cncEnvOutEdt	Dispatch.c	/^ocrGuid_t cncEnvOutEdt(u32 paramc, u64 paramv[], u32 depc, ocrEdtDep_t depv[]) {$/;"	f
cncEnvOutTag	Context.h	/^	ocrGuid_t cncEnvOutTag;$/;"	m	struct:Context
cncEnvOut_gets	Common.c	/^ocrGuid_t cncEnvOut_gets(u32 paramc, u64 paramv[], u32 depc, ocrEdtDep_t depv[]){$/;"	f
cncPrescribe_advancePositionStep	Common.c	/^void cncPrescribe_advancePositionStep(int i, int iter, Context *context){$/;"	f
cncPrescribe_advanceVelocityStep	Common.c	/^void cncPrescribe_advanceVelocityStep(int i, int iter, Context *context){$/;"	f
cncPrescribe_cncEnvOut	Context.c	/^void cncPrescribe_cncEnvOut(int i, int iter, Context *context) {$/;"	f
cncPrescribe_forceStep	Common.c	/^void cncPrescribe_forceStep(int i, int l, int iter, Context *context){$/;"	f
cncPrescribe_generateForceTagsStep	Common.c	/^void cncPrescribe_generateForceTagsStep(int N, int iter, Context *context){$/;"	f
cncPrescribe_reduceStep	Common.c	/^void cncPrescribe_reduceStep(int i, int iter, Context *context){$/;"	f
cncPrescribe_syncBoxesStep	Common.c	/^void cncPrescribe_syncBoxesStep(int i, int iter, Context *context){$/;"	f
cncPrescribe_updateBoxStep	Common.c	/^void cncPrescribe_updateBoxStep(int i, int l, int k, int iter, Context *context){$/;"	f
cncPrescribe_updatedAtomInfoStep	Common.c	/^void cncPrescribe_updatedAtomInfoStep(int i, int iter, Context *context){$/;"	f
cncPutChecked_ATOMS	Context.c	/^void cncPutChecked_ATOMS(cncHandle_t handle, int kc0, bool checkSingleAssignment, Context *context) {$/;"	f
cncPutChecked_AperB	Context.c	/^void cncPutChecked_AperB(cncHandle_t handle, int kc0, bool checkSingleAssignment, Context *context) {$/;"	f
cncPutChecked_B	Context.c	/^void cncPutChecked_B(cncHandle_t handle, int kc0, int kc1, int kc2, int kc3, bool checkSingleAssignment, Context *context) {$/;"	f
cncPutChecked_DD	Context.c	/^void cncPutChecked_DD(cncHandle_t handle, int kc0, bool checkSingleAssignment, Context *context) {$/;"	f
cncPutChecked_IT	Context.c	/^void cncPutChecked_IT(cncHandle_t handle, int kc0, bool checkSingleAssignment, Context *context) {$/;"	f
cncPutChecked_LC	Context.c	/^void cncPutChecked_LC(cncHandle_t handle, int kc0, bool checkSingleAssignment, Context *context) {$/;"	f
cncPutChecked_NAtoms	Context.c	/^void cncPutChecked_NAtoms(cncHandle_t handle, int kc0, bool checkSingleAssignment, Context *context) {$/;"	f
cncPutChecked_Nbs	Context.c	/^void cncPutChecked_Nbs(cncHandle_t handle, int kc0, bool checkSingleAssignment, Context *context) {$/;"	f
cncPutChecked_POT	Context.c	/^void cncPutChecked_POT(cncHandle_t handle, int kc0, bool checkSingleAssignment, Context *context) {$/;"	f
cncPutChecked_SF	Context.c	/^void cncPutChecked_SF(cncHandle_t handle, int kc0, bool checkSingleAssignment, Context *context) {$/;"	f
cncPutChecked_SPECIES	Context.c	/^void cncPutChecked_SPECIES(cncHandle_t handle, int kc0, bool checkSingleAssignment, Context *context) {$/;"	f
cncPutChecked_TAtoms	Context.c	/^void cncPutChecked_TAtoms(cncHandle_t handle, int kc0, bool checkSingleAssignment, Context *context) {$/;"	f
cncPutChecked_TBoxes	Context.c	/^void cncPutChecked_TBoxes(cncHandle_t handle, int kc0, bool checkSingleAssignment, Context *context) {$/;"	f
cncPutChecked_UI	Context.c	/^void cncPutChecked_UI(cncHandle_t handle, int kc0, int kc1, int kc2, bool checkSingleAssignment, Context *context) {$/;"	f
cncPutChecked_redc	Context.c	/^void cncPutChecked_redc(cncHandle_t handle, int kc0, int kc1, bool checkSingleAssignment, Context *context) {$/;"	f
cncPutChecked_s	Context.c	/^void cncPutChecked_s(cncHandle_t handle, int kc0, int kc1, bool checkSingleAssignment, Context *context) {$/;"	f
cncPut_ATOMS	Context.h	147;"	d
cncPut_AperB	Context.h	135;"	d
cncPut_B	Context.h	117;"	d
cncPut_DD	Context.h	141;"	d
cncPut_IT	Context.h	127;"	d
cncPut_LC	Context.h	143;"	d
cncPut_NAtoms	Context.h	145;"	d
cncPut_Nbs	Context.h	121;"	d
cncPut_POT	Context.h	137;"	d
cncPut_SF	Context.h	119;"	d
cncPut_SPECIES	Context.h	139;"	d
cncPut_TAtoms	Context.h	133;"	d
cncPut_TBoxes	Context.h	129;"	d
cncPut_UI	Context.h	123;"	d
cncPut_redc	Context.h	131;"	d
cncPut_s	Context.h	125;"	d
comdCalloc	memUtils.h	/^static void* comdCalloc(size_t num, size_t iSize)$/;"	f
comdFree	memUtils.h	/^static void comdFree(void *ptr)$/;"	f
comdMalloc	memUtils.h	/^static void* comdMalloc(size_t iSize)$/;"	f
comdRealloc	memUtils.h	/^static void* comdRealloc(void* ptr, size_t iSize)$/;"	f
computeForce	timestep.c	/^void computeForce(SimFlat* s)$/;"	f
computeVcm	initAtoms.c	/^void computeVcm(SimFlat* s, real_t vcm[3])$/;"	f
copyAtom	linkCells.c	/^void copyAtom(LinkCell* boxes, Atoms* atoms, int iAtom, int iBox, int jAtom, int jBox)$/;"	f
count	Context.h	/^	ItemCollectionEntry **count;$/;"	m	struct:Context
countItem	Context.h	/^typedef struct { int item; cncHandle_t handle; } countItem;$/;"	t	typeref:struct:__anon3
createFccLattice	initAtoms.c	/^void createFccLattice(int nx, int ny, int nz, real_t lat, SimFlat* s)$/;"	f
cutoff	CoMDTypes.h	/^   real_t cutoff;          \/\/!< potential cutoff distance in Angstroms$/;"	m	struct:BasePotentialSt
cutoff	CoMDTypes.h	/^   real_t cutoff;          \/\/!< potential cutoff distance in Angstroms$/;"	m	struct:LjPotentialSt
deleteGraph	Context.c	/^void deleteGraph(Context *CnCGraph) {$/;"	f
destroy	CoMDTypes.h	/^   void (*destroy)(BasePotential** pot); \/\/!< destruction of the potential$/;"	m	struct:LjPotentialSt
destroy	haloExchange.h	/^   void (*destroy)(void* parms);$/;"	m	struct:HaloExchangeSt
destroyAtoms	initAtoms.c	/^void destroyAtoms(Atoms *atoms)$/;"	f
destroyAtomsExchange	haloExchange.c	/^void destroyAtomsExchange(void* vparms)$/;"	f
destroyHaloExchange	haloExchange.c	/^void destroyHaloExchange(HaloExchange** haloExchange)$/;"	f
destroyLinkCells	linkCells.c	/^void destroyLinkCells(LinkCell** boxes)$/;"	f
destroyParallel	parallel.c	/^void destroyParallel()$/;"	f
dfEmbed	haloExchange.c	/^   real_t dfEmbed;$/;"	m	struct:ForceMsgSt	file:
doeam	mycommand.h	/^   int doeam;          \/\/!< a flag to determine whether we're running EAM potentials$/;"	m	struct:CommandSt
domain	CoMDTypes.h	/^   Domain* domain;        \/\/<! domain decomposition data$/;"	m	struct:SimFlatSt
dt	CoMDTypes.h	/^   double dt;             \/\/<! time step$/;"	m	struct:SimFlatSt
dt	mycommand.h	/^   double dt;          \/\/!< time step (in femtoseconds)$/;"	m	struct:CommandSt
dupString	cmdLineParser.c	/^static char* dupString(const char* s)$/;"	f	file:
eKin	CoMDTypes.h	/^    double eKin;$/;"	m	struct:box
eKin	CoMDTypes.h	/^    double eKin;$/;"	m	struct:myReduction
eKinetic	CoMDTypes.h	/^   real_t eKinetic;       \/\/!< the total kinetic energy of the system$/;"	m	struct:SimFlatSt
ePot	CoMDTypes.h	/^    double ePot;$/;"	m	struct:box
ePot	CoMDTypes.h	/^    double ePot;$/;"	m	struct:myReduction
ePotential	CoMDTypes.h	/^   real_t ePotential;     \/\/!< the total potential energy of the system$/;"	m	struct:SimFlatSt
eTot0	CoMDTypes.h	/^   double eTot0; \/\/<! Initial total energy$/;"	m	struct:ValidateSt
eVInJoules	constants.h	25;"	d
emptyHaloCells	linkCells.c	/^void emptyHaloCells(LinkCell* boxes)$/;"	f
epsilon	CoMDTypes.h	/^   real_t epsilon;$/;"	m	struct:LjPotentialSt
exchangeData	haloExchange.c	/^void exchangeData(HaloExchange* haloExchange, void* data, int iAxis)$/;"	f
f	initAtoms.h	/^   real3*  f;     \/\/!< forces $/;"	m	struct:AtomsSt
findOption	cmdLineParser.c	/^static MyOption* findOption(MyOption* o, unsigned char shortArg)$/;"	f	file:
force	CoMDTypes.h	/^   int  (*force)(SimFlat* s); \/\/!< function pointer to force routine$/;"	m	struct:LjPotentialSt
force	CoMDTypes.h	/^   int  (*force)(struct SimFlatSt* s); \/\/!< function pointer to force routine$/;"	m	struct:BasePotentialSt
force	forceStep.c	/^int force(SimFlat* s, int i, int iter, struct box *b) {$/;"	f
forceStep	Context.h	/^	ocrGuid_t forceStep;$/;"	m	struct:Context
forceStep	forceStep.c	/^void forceStep (int i, int j, int iter, BItem b1, SFItem sf,  ITItem it, Context *context) {$/;"	f
forceStep_gets	Common.c	/^ocrGuid_t forceStep_gets(u32 paramc, u64 paramv[], u32 depc, ocrEdtDep_t depv[]){$/;"	f
freeArgs	cmdLineParser.c	/^void freeArgs()$/;"	f
freeMe	memUtils.h	9;"	d
from	CoMDTypes.h	/^    int from;  \/\/ from box$/;"	m	struct:info
fsInSeconds	constants.h	19;"	d
gasdev	random.c	/^real_t gasdev(uint64_t* seed)$/;"	f
generateForceTagsStep	Context.h	/^	ocrGuid_t generateForceTagsStep;$/;"	m	struct:Context
generateForceTagsStep	generateForceTagsStep.c	/^void generateForceTagsStep (int N, int iter, sItem s, TBoxesItem tb, NbsItem nb, Context *context) {$/;"	f
generateForceTagsStep_gets	Common.c	/^ocrGuid_t generateForceTagsStep_gets(u32 paramc, u64 paramv[], u32 depc, ocrEdtDep_t depv[]){$/;"	f
getBoxFromCoord	linkCells.c	/^int getBoxFromCoord(LinkCell* boxes, real_t rr[3])$/;"	f
getBoxFromTuple	linkCells.c	/^int getBoxFromTuple(LinkCell* boxes, int ix, int iy, int iz)$/;"	f
getMyRank	parallel.c	/^int getMyRank()   $/;"	f
getNRanks	parallel.c	/^int getNRanks()$/;"	f
getNeighborBoxes	linkCells.c	/^int getNeighborBoxes(LinkCell* boxes, int iBox, int* nbrBoxes)$/;"	f
getTimeString	yamlOutput.c	/^static void getTimeString(char* timestring)$/;"	f	file:
getTuple	linkCells.c	/^void getTuple(LinkCell* boxes, int iBox, int* ixp, int* iyp, int* izp)$/;"	f
gid	haloExchange.c	/^   int gid;$/;"	m	struct:AtomMsgSt	file:
gid	initAtoms.h	/^   int* gid;      \/\/!< A globally unique id for each atom$/;"	m	struct:AtomsSt
globalExtent	decomposition.h	/^   real3 globalExtent;     \/\/!< global size: globalMax - globalMin$/;"	m	struct:DomainSt
globalMax	decomposition.h	/^   real3 globalMax;        \/\/!< maximum global coordinate (angstroms)$/;"	m	struct:DomainSt
globalMin	decomposition.h	/^   real3 globalMin;        \/\/!< minimum global coordinate (angstroms)$/;"	m	struct:DomainSt
gridSize	linkCells.h	/^   int gridSize[3];     \/\/!< number of boxes in each dimension on processor$/;"	m	struct:LinkCellSt
haloExchange	haloExchange.c	/^void haloExchange(HaloExchange* haloExchange, void* data)$/;"	f
handle	Context.h	/^typedef struct { Atoms *item; cncHandle_t handle; } ATOMSItem;$/;"	m	struct:__anon11
handle	Context.h	/^typedef struct { Domain *item; cncHandle_t handle; } DDItem;$/;"	m	struct:__anon8
handle	Context.h	/^typedef struct { LinkCell *item; cncHandle_t handle; } LCItem;$/;"	m	struct:__anon9
handle	Context.h	/^typedef struct { LjPotential *item; cncHandle_t handle; } POTItem;$/;"	m	struct:__anon6
handle	Context.h	/^typedef struct { SimFlat *item; cncHandle_t handle; } SFItem;$/;"	m	struct:__anon5
handle	Context.h	/^typedef struct { SpeciesData *item; cncHandle_t handle; } SPECIESItem;$/;"	m	struct:__anon7
handle	Context.h	/^typedef struct { int *item; cncHandle_t handle; } GIDItem;$/;"	m	struct:__anon12
handle	Context.h	/^typedef struct { int *item; cncHandle_t handle; } ISPItem;$/;"	m	struct:__anon13
handle	Context.h	/^typedef struct { int *item; cncHandle_t handle; } NAtomsItem;$/;"	m	struct:__anon10
handle	Context.h	/^typedef struct { int *item; cncHandle_t handle; } sItem;$/;"	m	struct:__anon4
handle	Context.h	/^typedef struct { int item; cncHandle_t handle; } AperBItem;$/;"	m	struct:__anon22
handle	Context.h	/^typedef struct { int item; cncHandle_t handle; } ITItem;$/;"	m	struct:__anon19
handle	Context.h	/^typedef struct { int item; cncHandle_t handle; } NbsItem;$/;"	m	struct:__anon23
handle	Context.h	/^typedef struct { int item; cncHandle_t handle; } TAtomsItem;$/;"	m	struct:__anon21
handle	Context.h	/^typedef struct { int item; cncHandle_t handle; } TBoxesItem;$/;"	m	struct:__anon20
handle	Context.h	/^typedef struct { int item; cncHandle_t handle; } countItem;$/;"	m	struct:__anon3
handle	Context.h	/^typedef struct { real3 *item; cncHandle_t handle; } FItem;$/;"	m	struct:__anon16
handle	Context.h	/^typedef struct { real3 *item; cncHandle_t handle; } PItem;$/;"	m	struct:__anon15
handle	Context.h	/^typedef struct { real3 *item; cncHandle_t handle; } RItem;$/;"	m	struct:__anon14
handle	Context.h	/^typedef struct { real_t *item; cncHandle_t handle; } UItem;$/;"	m	struct:__anon17
handle	Context.h	/^typedef struct { struct box *item; cncHandle_t handle; } BItem;$/;"	m	struct:__anon1
handle	Context.h	/^typedef struct { struct info *item; cncHandle_t handle; } UIItem;$/;"	m	struct:__anon2
handle	Context.h	/^typedef struct { struct myReduction *item; cncHandle_t handle; } redcItem;$/;"	m	struct:__anon18
hartreeToEv	constants.h	/^static const double hartreeToEv = 27.21138505;$/;"	v
help	cmdLineParser.c	/^   char* help;$/;"	m	struct:MyOptionSt	file:
i	CoMDTypes.h	/^    int i;  \/\/ box number$/;"	m	struct:box
i	CoMDTypes.h	/^    int i;$/;"	m	struct:myReduction
iSpecies	initAtoms.h	/^   int* iSpecies; \/\/!< the species index of the atom$/;"	m	struct:AtomsSt
info	CoMDTypes.h	/^struct info {$/;"	s
initAtomHaloExchange	haloExchange.c	/^HaloExchange* initAtomHaloExchange(Domain* domain, LinkCell* boxes)$/;"	f
initAtoms	initAtoms.c	/^Atoms* initAtoms(LinkCell* boxes, Context *context)$/;"	f
initDecomposition	decomposition.c	/^Domain* initDecomposition(int xproc, int yproc, int zproc, real3 globalExtent, Context *context)$/;"	f
initGraph	Context.c	/^Context *initGraph() {$/;"	f
initHaloExchange	haloExchange.c	/^HaloExchange* initHaloExchange(Domain* domain)$/;"	f
initLinkCells	linkCells.c	/^LinkCell* initLinkCells(const Domain* domain, real_t cutoff, Context *context)$/;"	f
initLjPot	ljForce.c	/^BasePotential* initLjPot(Context *context)$/;"	f
initParallel	parallel.c	/^void initParallel(int* argc, char*** argv)$/;"	f
initPotential	Main.c	/^BasePotential* initPotential($/;"	f
initSimulationNew	Main.c	/^SimFlat* initSimulationNew(Command cmd, Context *context) {$/;"	f
initSpecies	Main.c	/^SpeciesData* initSpecies(BasePotential* pot, Context *context)$/;"	f
initSubsystems	Main.c	/^void initSubsystems(void) {$/;"	f
initValidate	Main.c	/^Validate* initValidate(SimFlat* sim)$/;"	f
initialDelta	mycommand.h	/^   double initialDelta; \/\/!< magnitude of initial displacement from lattice (in Angstroms)$/;"	m	struct:CommandSt
invBoxSize	linkCells.h	/^   real3 invBoxSize;    \/\/!< inverse size of box in each dimension$/;"	m	struct:LinkCellSt
item	Context.h	/^typedef struct { Atoms *item; cncHandle_t handle; } ATOMSItem;$/;"	m	struct:__anon11
item	Context.h	/^typedef struct { Domain *item; cncHandle_t handle; } DDItem;$/;"	m	struct:__anon8
item	Context.h	/^typedef struct { LinkCell *item; cncHandle_t handle; } LCItem;$/;"	m	struct:__anon9
item	Context.h	/^typedef struct { LjPotential *item; cncHandle_t handle; } POTItem;$/;"	m	struct:__anon6
item	Context.h	/^typedef struct { SimFlat *item; cncHandle_t handle; } SFItem;$/;"	m	struct:__anon5
item	Context.h	/^typedef struct { SpeciesData *item; cncHandle_t handle; } SPECIESItem;$/;"	m	struct:__anon7
item	Context.h	/^typedef struct { int *item; cncHandle_t handle; } GIDItem;$/;"	m	struct:__anon12
item	Context.h	/^typedef struct { int *item; cncHandle_t handle; } ISPItem;$/;"	m	struct:__anon13
item	Context.h	/^typedef struct { int *item; cncHandle_t handle; } NAtomsItem;$/;"	m	struct:__anon10
item	Context.h	/^typedef struct { int *item; cncHandle_t handle; } sItem;$/;"	m	struct:__anon4
item	Context.h	/^typedef struct { int item; cncHandle_t handle; } AperBItem;$/;"	m	struct:__anon22
item	Context.h	/^typedef struct { int item; cncHandle_t handle; } ITItem;$/;"	m	struct:__anon19
item	Context.h	/^typedef struct { int item; cncHandle_t handle; } NbsItem;$/;"	m	struct:__anon23
item	Context.h	/^typedef struct { int item; cncHandle_t handle; } TAtomsItem;$/;"	m	struct:__anon21
item	Context.h	/^typedef struct { int item; cncHandle_t handle; } TBoxesItem;$/;"	m	struct:__anon20
item	Context.h	/^typedef struct { int item; cncHandle_t handle; } countItem;$/;"	m	struct:__anon3
item	Context.h	/^typedef struct { real3 *item; cncHandle_t handle; } FItem;$/;"	m	struct:__anon16
item	Context.h	/^typedef struct { real3 *item; cncHandle_t handle; } PItem;$/;"	m	struct:__anon15
item	Context.h	/^typedef struct { real3 *item; cncHandle_t handle; } RItem;$/;"	m	struct:__anon14
item	Context.h	/^typedef struct { real_t *item; cncHandle_t handle; } UItem;$/;"	m	struct:__anon17
item	Context.h	/^typedef struct { struct box *item; cncHandle_t handle; } BItem;$/;"	m	struct:__anon1	typeref:struct:__anon1::box
item	Context.h	/^typedef struct { struct info *item; cncHandle_t handle; } UIItem;$/;"	m	struct:__anon2	typeref:struct:__anon2::info
item	Context.h	/^typedef struct { struct myReduction *item; cncHandle_t handle; } redcItem;$/;"	m	struct:__anon18	typeref:struct:__anon18::myReduction
kB_eV	constants.h	/^static const double kB_eV = 8.6173324e-5;  \/\/ eV\/K$/;"	v
kineticEnergy	timestep.c	/^void kineticEnergy(SimFlat* s)$/;"	f
lastOption	cmdLineParser.c	/^static MyOption* lastOption(MyOption* o)$/;"	f	file:
lat	CoMDTypes.h	/^   real_t lat;             \/\/!< lattice spacing (angs) of unit cell$/;"	m	struct:BasePotentialSt
lat	CoMDTypes.h	/^   real_t lat;             \/\/!< lattice spacing (angs) of unit cell$/;"	m	struct:LjPotentialSt
lat	mycommand.h	/^   double lat;         \/\/!< lattice constant (in Angstroms)$/;"	m	struct:CommandSt
latticeType	CoMDTypes.h	/^   char latticeType[8];    \/\/!< lattice type, e.g. FCC, BCC, etc.$/;"	m	struct:BasePotentialSt
latticeType	CoMDTypes.h	/^   char latticeType[8];    \/\/!< lattice type, e.g. FCC, BCC, etc.$/;"	m	struct:LjPotentialSt
lcg61	random.c	/^double lcg61(uint64_t* seed)$/;"	f
ljDestroy	ljForce.c	/^void ljDestroy(BasePotential** inppot)$/;"	f
ljForce	ljForce.c	/^int ljForce(SimFlat* s)$/;"	f
ljPrint	ljForce.c	/^void ljPrint(FILE* file, BasePotential* pot)$/;"	f
loadAtomsBuffer	haloExchange.c	/^int loadAtomsBuffer(void* vparms, void* data, int face, char* charBuf)$/;"	f
loadBuffer	haloExchange.h	/^   int  (*loadBuffer)(void* parms, void* data, int face, char* buf);$/;"	m	struct:HaloExchangeSt
localExtent	decomposition.h	/^   real3 localExtent;      \/\/!< localMax - localMin$/;"	m	struct:DomainSt
localMax	decomposition.h	/^   real3 localMax;         \/\/!< maximum coordinate on local processor$/;"	m	struct:DomainSt
localMax	linkCells.h	/^   real3 localMax;      \/\/!< maximum local bounds on processor$/;"	m	struct:LinkCellSt
localMin	decomposition.h	/^   real3 localMin;         \/\/!< minimum coordinate on local processor$/;"	m	struct:DomainSt
localMin	linkCells.h	/^   real3 localMin;      \/\/!< minimum local bounds on processor$/;"	m	struct:LinkCellSt
longArg	cmdLineParser.c	/^   char* longArg;$/;"	m	struct:MyOptionSt	file:
longest	cmdLineParser.c	/^static int longest = 1;$/;"	v	file:
mainEdt	Dispatch.c	/^ocrGuid_t mainEdt(u32 paramc, u64 paramv[], u32 depc, ocrEdtDep_t depv[]) {$/;"	f
mass	CoMDTypes.h	/^   real_t mass;            \/\/!< mass of atoms in intenal units$/;"	m	struct:BasePotentialSt
mass	CoMDTypes.h	/^   real_t mass;            \/\/!< mass of atoms in intenal units$/;"	m	struct:LjPotentialSt
mass	CoMDTypes.h	/^   real_t mass;     \/\/!< mass in internal units$/;"	m	struct:SpeciesDataSt
maxIntParallel	parallel.c	/^void maxIntParallel(int* sendBuf, int* recvBuf, int count)$/;"	f
maxOccupancy	linkCells.c	/^int maxOccupancy(LinkCell* boxes)$/;"	f
maxRankDoubleParallel	parallel.c	/^void maxRankDoubleParallel(RankReduceData* sendBuf, RankReduceData* recvBuf, int count)$/;"	f
minRankDoubleParallel	parallel.c	/^void minRankDoubleParallel(RankReduceData* sendBuf, RankReduceData* recvBuf, int count)$/;"	f
mkAtomCellList	haloExchange.c	/^int* mkAtomCellList(LinkCell* boxes, enum HaloFaceOrder iFace, const int nCells)$/;"	f
mkForceRecvCellList	haloExchange.c	/^int* mkForceRecvCellList(LinkCell* boxes, int face, int nCells)$/;"	f
mkForceSendCellList	haloExchange.c	/^int* mkForceSendCellList(LinkCell* boxes, int face, int nCells)$/;"	f
mkSeed	random.c	/^uint64_t mkSeed(uint32_t id, uint32_t callSite)$/;"	f
moveAtom	linkCells.c	/^void moveAtom(LinkCell* boxes, Atoms* atoms, int iId, int iBox, int jBox)$/;"	f
myOptionAlloc	cmdLineParser.c	/^static MyOption* myOptionAlloc($/;"	f	file:
myOptionFree	cmdLineParser.c	/^static MyOption* myOptionFree(MyOption* o)$/;"	f	file:
myRank	parallel.c	/^static int myRank = 0;$/;"	v	file:
myReduction	CoMDTypes.h	/^struct myReduction {$/;"	s
myargs	cmdLineParser.c	/^static MyOption* myargs=NULL;$/;"	v	file:
n	CoMDTypes.h	/^    int n;  \/\/ number of atoms$/;"	m	struct:info
n	CoMDTypes.h	/^    int n;  \/\/ total number of data elements n < 10$/;"	m	struct:box
nAtoms	linkCells.h	/^   int* nAtoms;         \/\/!< total number of atoms in each box$/;"	m	struct:LinkCellSt
nAtoms0	CoMDTypes.h	/^   int nAtoms0;  \/\/<! Initial global number of atoms$/;"	m	struct:ValidateSt
nCells	haloExchange.c	/^   int nCells[6];        \/\/!< Number of cells in cellList for each face.$/;"	m	struct:AtomExchangeParmsSt	file:
nCells	haloExchange.c	/^   int nCells[6];     \/\/!< Number of cells to send\/recv for each face.$/;"	m	struct:ForceExchangeParmsSt	file:
nGlobal	initAtoms.h	/^   int nGlobal;   \/\/!< total number of atoms in simulation$/;"	m	struct:AtomsSt
nHaloBoxes	linkCells.h	/^   int nHaloBoxes;      \/\/!< total number of remote halo\/ghost boxes on processor$/;"	m	struct:LinkCellSt
nLocal	initAtoms.h	/^   int nLocal;    \/\/!< total number of atoms on this processor$/;"	m	struct:AtomsSt
nLocalBoxes	linkCells.h	/^   int nLocalBoxes;     \/\/!< total number of local boxes on processor$/;"	m	struct:LinkCellSt
nRanks	parallel.c	/^static int nRanks = 1;$/;"	v	file:
nSteps	CoMDTypes.h	/^   int nSteps;            \/\/<! number of time steps to run$/;"	m	struct:SimFlatSt
nSteps	mycommand.h	/^   int nSteps;         \/\/!< number of time steps to run$/;"	m	struct:CommandSt
nTotalBoxes	linkCells.h	/^   int nTotalBoxes;     \/\/!< total number of boxes on processor$/;"	m	struct:LinkCellSt
name	CoMDTypes.h	/^   char  name[3];      \/\/!< element name$/;"	m	struct:BasePotentialSt
name	CoMDTypes.h	/^   char  name[3];      \/\/!< element name$/;"	m	struct:LjPotentialSt
name	CoMDTypes.h	/^   char  name[3];   \/\/!< element name$/;"	m	struct:SpeciesDataSt
nbrRank	haloExchange.h	/^   int nbrRank[6];$/;"	m	struct:HaloExchangeSt
next	cmdLineParser.c	/^   void* next;$/;"	m	struct:MyOptionSt	file:
nextOption	cmdLineParser.c	19;"	d	file:
nx	mycommand.h	/^   int nx;             \/\/!< number of unit cells in x$/;"	m	struct:CommandSt
ny	mycommand.h	/^   int ny;             \/\/!< number of unit cells in y$/;"	m	struct:CommandSt
nz	mycommand.h	/^   int nz;             \/\/!< number of unit cells in z$/;"	m	struct:CommandSt
p	initAtoms.h	/^   real3*  p;     \/\/!< momenta of atoms$/;"	m	struct:AtomsSt
parms	haloExchange.h	/^   void* parms;$/;"	m	struct:HaloExchangeSt
parseCommandLine	mycommand.c	/^Command parseCommandLine(int argc, char** argv)$/;"	f
pbcFactor	haloExchange.c	/^   real_t* pbcFactor[6]; \/\/!< Whether this face is a periodic boundary.$/;"	m	struct:AtomExchangeParmsSt	file:
pot	CoMDTypes.h	/^   BasePotential *pot;    \/\/!< the potential$/;"	m	struct:SimFlatSt
potDir	mycommand.h	/^   char potDir[1024];  \/\/!< the directory where EAM potentials reside$/;"	m	struct:CommandSt
potName	mycommand.h	/^   char potName[1024]; \/\/!< the name of the potential$/;"	m	struct:CommandSt
potType	mycommand.h	/^   char potType[1024]; \/\/!< the type of the potential (funcfl or setfl)$/;"	m	struct:CommandSt
print	CoMDTypes.h	/^   void (*print)(FILE* file, BasePotential* pot);$/;"	m	struct:LjPotentialSt
printArgs	cmdLineParser.c	/^void printArgs()$/;"	f
printCmdYaml	mycommand.c	/^void printCmdYaml(FILE* file, Command* cmd)$/;"	f
printRank	parallel.c	/^int printRank()$/;"	f
printRate	CoMDTypes.h	/^   int printRate;         \/\/<! number of steps between output$/;"	m	struct:SimFlatSt
printRate	mycommand.h	/^   int printRate;      \/\/!< number of steps between output$/;"	m	struct:CommandSt
printSeparator	yamlOutput.c	/^void printSeparator(FILE* file)$/;"	f
printSimulationDataYaml	Main.c	/^void printSimulationDataYaml(FILE* file, SimFlat* s)$/;"	f
procCoord	decomposition.h	/^   int procCoord[3];       \/\/!< i,j,k for this processor$/;"	m	struct:DomainSt
procGrid	decomposition.h	/^   int procGrid[3];        \/\/!< number of processors in each dimension$/;"	m	struct:DomainSt
processArgs	cmdLineParser.c	/^void processArgs(int argc, char** argv)$/;"	f
processorNum	decomposition.c	/^int processorNum(Domain* domain, int dix, int diy, int diz)$/;"	f
ptr	cmdLineParser.c	/^   void* ptr;$/;"	m	struct:MyOptionSt	file:
putAtomInBox	linkCells.c	/^void putAtomInBox(LinkCell* boxes, Atoms* atoms,$/;"	f
px	haloExchange.c	/^   real_t px, py, pz;$/;"	m	struct:AtomMsgSt	file:
py	haloExchange.c	/^   real_t px, py, pz;$/;"	m	struct:AtomMsgSt	file:
pz	haloExchange.c	/^   real_t px, py, pz;$/;"	m	struct:AtomMsgSt	file:
r	initAtoms.h	/^   real3*  r;     \/\/!< positions$/;"	m	struct:AtomsSt
randomDisplacements	initAtoms.c	/^void randomDisplacements(SimFlat* s, real_t delta)$/;"	f
rank	parallel.h	/^   int rank;$/;"	m	struct:RankReduceDataSt
real3	mytype.h	/^typedef real_t real3[3]; \/\/!< a convenience vector with three real_t $/;"	t
real_t	mytype.h	/^typedef double real_t; \/\/!< define native type for CoMD as double precision$/;"	t
real_t	mytype.h	/^typedef float real_t;  \/\/!< define native type for CoMD as single precision$/;"	t
recvCells	haloExchange.c	/^   int* recvCells[6]; \/\/!< List of link cells to recv for each face.$/;"	m	struct:ForceExchangeParmsSt	file:
redc	Context.h	/^	ItemCollectionEntry **redc;$/;"	m	struct:Context
redcItem	Context.h	/^typedef struct { struct myReduction *item; cncHandle_t handle; } redcItem;$/;"	t	typeref:struct:__anon18
redistributeAtoms	timestep.c	/^void redistributeAtoms(SimFlat* sim)$/;"	f
reduceStep	Context.h	/^	ocrGuid_t reduceStep;$/;"	m	struct:Context
reduceStep	reduceStep.c	/^void reduceStep (int i, int iter, BItem b,  redcItem rd, ITItem it, TBoxesItem tb, Context *context) {$/;"	f
reduceStep_gets	Common.c	/^ocrGuid_t reduceStep_gets(u32 paramc, u64 paramv[], u32 depc, ocrEdtDep_t depv[]){$/;"	f
rx	haloExchange.c	/^   real_t rx, ry, rz;$/;"	m	struct:AtomMsgSt	file:
ry	haloExchange.c	/^   real_t rx, ry, rz;$/;"	m	struct:AtomMsgSt	file:
rz	haloExchange.c	/^   real_t rx, ry, rz;$/;"	m	struct:AtomMsgSt	file:
s	Context.h	/^	ItemCollectionEntry **s;$/;"	m	struct:Context
sItem	Context.h	/^typedef struct { int *item; cncHandle_t handle; } sItem;$/;"	t	typeref:struct:__anon4
sanityChecks	Main.c	/^void sanityChecks(Command cmd, double cutoff, double latticeConst, char latticeType[8]) {$/;"	f
screenOut	mytype.h	27;"	d
sendCells	haloExchange.c	/^   int* sendCells[6]; \/\/!< List of link cells to send for each face.$/;"	m	struct:ForceExchangeParmsSt	file:
sendReceiveParallel	parallel.c	/^int sendReceiveParallel(void* sendBuf, int sendLen, int dest,$/;"	f
setTemperature	initAtoms.c	/^void setTemperature(SimFlat* s, real_t temperature)$/;"	f
setVcm	initAtoms.c	/^void setVcm(SimFlat* s, real_t newVcm[3])$/;"	f
shortArg	cmdLineParser.c	/^   unsigned char shortArg[2];$/;"	m	struct:MyOptionSt	file:
sigma	CoMDTypes.h	/^   real_t sigma;$/;"	m	struct:LjPotentialSt
sortAtomsById	haloExchange.c	/^int sortAtomsById(const void* a, const void* b)$/;"	f
sortAtomsInCell	haloExchange.c	/^void sortAtomsInCell(Atoms* atoms, LinkCell* boxes, int iBox)$/;"	f
species	CoMDTypes.h	/^   SpeciesData* species;  \/\/<! species data (per species, not per atom)$/;"	m	struct:SimFlatSt
sumAtoms	Main.c	/^void sumAtoms(SimFlat* s)$/;"	f
syncBoxesStep	Context.h	/^	ocrGuid_t syncBoxesStep;$/;"	m	struct:Context
syncBoxesStep	syncBoxesStep.c	/^void syncBoxesStep (int i, int iter, sItem s, ITItem it, TBoxesItem tb, Context *context) {$/;"	f
syncBoxesStep_gets	Common.c	/^ocrGuid_t syncBoxesStep_gets(u32 paramc, u64 paramv[], u32 depc, ocrEdtDep_t depv[]){$/;"	f
sz	cmdLineParser.c	/^   int sz;$/;"	m	struct:MyOptionSt	file:
temperature	mycommand.h	/^   double temperature; \/\/!< simulation initial temperature (in Kelvin)$/;"	m	struct:CommandSt
timestampBarrier	parallel.c	/^void timestampBarrier(const char* msg)$/;"	f
timestep	timestep.c	/^double timestep(SimFlat* s, int nSteps, real_t dt)$/;"	f
to	CoMDTypes.h	/^    int to; \/\/ to box$/;"	m	struct:info
type	cmdLineParser.c	/^   char type;$/;"	m	struct:MyOptionSt	file:
type	haloExchange.c	/^   int type;$/;"	m	struct:AtomMsgSt	file:
unloadAtomsBuffer	haloExchange.c	/^void unloadAtomsBuffer(void* vparms, void* data, int face, int bufSize, char* charBuf)$/;"	f
unloadBuffer	haloExchange.h	/^   void (*unloadBuffer)(void* parms, void* data, int face, int bufSize, char* buf);$/;"	m	struct:HaloExchangeSt
updateBoxStep	Context.h	/^	ocrGuid_t updateBoxStep;$/;"	m	struct:Context
updateBoxStep	updateBoxStep.c	/^void updateBoxStep (int i, int l, int k, int iter, BItem b1, UIItem ui, NbsItem nbs, Context *context) {$/;"	f
updateBoxStep_gets	Common.c	/^ocrGuid_t updateBoxStep_gets(u32 paramc, u64 paramv[], u32 depc, ocrEdtDep_t depv[]){$/;"	f
updateLinkCells	linkCells.c	/^void updateLinkCells(LinkCell* boxes, Atoms* atoms)$/;"	f
updatedAtomInfoStep	Context.h	/^	ocrGuid_t updatedAtomInfoStep;$/;"	m	struct:Context
updatedAtomInfoStep	updatedAtomInfoStep.c	/^void updatedAtomInfoStep (int i, int iter, BItem b1, NbsItem nbs, Context *context) {$/;"	f
updatedAtomInfoStep_gets	Common.c	/^ocrGuid_t updatedAtomInfoStep_gets(u32 paramc, u64 paramv[], u32 depc, ocrEdtDep_t depv[]){$/;"	f
val	parallel.h	/^   double val;$/;"	m	struct:RankReduceDataSt
validateResult	Main.c	/^void validateResult(const Validate* val, SimFlat* sim)$/;"	f
xproc	mycommand.h	/^   int xproc;          \/\/!< number of processors in x direction$/;"	m	struct:CommandSt
yamlAppInfo	yamlOutput.c	/^void yamlAppInfo(FILE* file)$/;"	f
yamlBegin	yamlOutput.c	/^void yamlBegin(void)$/;"	f
yamlEnd	yamlOutput.c	/^void yamlEnd(void)$/;"	f
yamlFile	yamlOutput.c	/^FILE* yamlFile = NULL;$/;"	v
yproc	mycommand.h	/^   int yproc;          \/\/!< number of processors in y direction$/;"	m	struct:CommandSt
zeroReal3	mytype.h	/^static void zeroReal3(real3 a)$/;"	f
zproc	mycommand.h	/^   int zproc;          \/\/!< number of processors in z direction$/;"	m	struct:CommandSt
